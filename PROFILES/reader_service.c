/******************************************************************************
 * Filename:       Reader_Service.c
 *
 * Description:    This file contains the implementation of the service.
 *
 *                 Generated by:
 *                 BDS version: 1.1.3135.0
 *                 Plugin:      Texas Instruments BLE SDK GATT Server plugin 1.0.8
 *                 Time:        Thu Sep 07 2017 05:39:13 GMT-04:00
 *

 * Copyright (c) 2015, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 **********************************************************************************/

/*********************************************************************
 * INCLUDES
 */
#include <string.h>

//#define xdc_runtime_Log_DISABLE_ALL 1  // Add to disable logs from this file
#include <xdc/runtime/Log.h>
#include <xdc/runtime/Diags.h>

#include "bcomdef.h"
#include "OSAL.h"
#include "linkdb.h"
#include "att.h"
#include "gatt.h"
#include "gatt_uuid.h"
#include "gattservapp.h"
#include "gapbondmgr.h"

#ifdef ICALL_LITE
#  include "icall_api.h" // Only exists for 3.x stack version, so use ifdef.
#endif

#include "reader_service.h"

/*********************************************************************
 * MACROS
 */

/*********************************************************************
 * CONSTANTS
 */

/*********************************************************************
 * TYPEDEFS
 */

/*********************************************************************
 * GLOBAL VARIABLES
 */

// Reader_Service Service UUID
CONST uint8_t ReaderServiceUUID[ATT_UUID_SIZE] = {
        READER_SERVICE_SERV_UUID_BASE128(READER_SERVICE_SERV_UUID) };

// payload UUID
CONST uint8_t rs_PayloadUUID[ATT_UUID_SIZE] = { RS_PAYLOAD_UUID_BASE128(
        RS_PAYLOAD_UUID)
};

// iniciado UUID
CONST uint8_t rs_IniciadoUUID[ATT_UUID_SIZE] = { RS_INICIADO_UUID_BASE128(
        RS_INICIADO_UUID)
};

// ciclo_de_lectura UUID
CONST uint8_t rs_Ciclo_de_lecturaUUID[ATT_UUID_SIZE] = {
        RS_CICLO_DE_LECTURA_UUID_BASE128(RS_CICLO_DE_LECTURA_UUID) };

// time UUID
CONST uint8_t rs_TimeUUID[ATT_UUID_SIZE] =
        { RS_TIME_UUID_BASE128(RS_TIME_UUID) };
// estado UUID
CONST uint8_t rs_EstadoUUID[ATT_UUID_SIZE] = { RS_ESTADO_UUID_BASE128(
        RS_ESTADO_UUID)
};

/*********************************************************************
 * LOCAL VARIABLES
 */

static ReaderServiceCBs_t *pAppCBs = NULL;
static uint8_t rs_icall_rsp_task_id = INVALID_TASK_ID;
static read_types_t tipo_de_lectura = NONE;

/*********************************************************************
 * Profile Attributes - variables
 */

// Service declaration
static CONST gattAttrType_t ReaderServiceDecl = { ATT_UUID_SIZE,
                                                  ReaderServiceUUID };

// Characteristic "payload" Properties (for declaration)
static uint8_t rs_PayloadProps = GATT_PROP_NOTIFY | GATT_PROP_READ;

// Characteristic "payload" Value variable
static uint8_t rs_PayloadVal[RS_PAYLOAD_LEN] = { 0 };

// Length of data in characteristic "payload" Value variable, initialized to minimal size.
static uint16_t rs_PayloadValLen = RS_PAYLOAD_LEN_MIN;

// Characteristic "payload" Client Characteristic Configuration Descriptor
static gattCharCfg_t *rs_PayloadConfig;

static uint8_t rs_IniciadoProps = GATT_PROP_NOTIFY | GATT_PROP_READ
        | GATT_PROP_WRITE | GATT_PROP_WRITE_NO_RSP;

static uint8_t rs_IniciadoVal[RS_INICIADO_LEN] = { 0 };

static uint16_t rs_IniciadoValLen = RS_INICIADO_LEN_MIN;

static gattCharCfg_t *rs_IniciadoConfig;

static uint8_t rs_Ciclo_de_lecturaProps = GATT_PROP_NOTIFY | GATT_PROP_READ
        | GATT_PROP_WRITE | GATT_PROP_WRITE_NO_RSP;

static uint8_t rs_Ciclo_de_lecturaVal[RS_CICLO_DE_LECTURA_LEN] = { 0 };

static uint16_t rs_Ciclo_de_lecturaValLen = RS_CICLO_DE_LECTURA_LEN_MIN;

static gattCharCfg_t *rs_Ciclo_de_lecturaConfig;

static uint8_t rs_TimeProps = GATT_PROP_READ | GATT_PROP_WRITE
        | GATT_PROP_WRITE_NO_RSP;

static uint8_t rs_TimeVal[RS_TIME_LEN] = { 0 };

static uint16_t rs_TimeValLen = RS_TIME_LEN_MIN;

static uint8_t rs_EstadoProps = GATT_PROP_NOTIFY | GATT_PROP_READ;

static uint8_t rs_EstadoVal[RS_ESTADO_LEN] = { 0 };

static uint16_t rs_EstadoValLen = RS_ESTADO_LEN_MIN;

static gattCharCfg_t *rs_EstadoConfig;

/*********************************************************************
 * Profile Attributes - Table
 */

static gattAttribute_t Reader_ServiceAttrTbl[] = {
// Reader_Service Service Declaration
        { { ATT_BT_UUID_SIZE, primaryServiceUUID },
        GATT_PERMIT_READ,
          0, (uint8_t *) &ReaderServiceDecl },

        // payload Characteristic Declaration
        { { ATT_BT_UUID_SIZE, characterUUID },
        GATT_PERMIT_READ,
          0, &rs_PayloadProps },
        // payload Characteristic Value
        { { ATT_UUID_SIZE, rs_PayloadUUID },
        GATT_PERMIT_READ,
          0, rs_PayloadVal },
        // payload CCCD
        { { ATT_BT_UUID_SIZE, clientCharCfgUUID },
        GATT_PERMIT_READ | GATT_PERMIT_WRITE,
          0, (uint8_t *) &rs_PayloadConfig },

        //Declaracion Iniciado
        { { ATT_BT_UUID_SIZE, characterUUID },
        GATT_PERMIT_READ,
          0, &rs_IniciadoProps },
        // valor
        { { ATT_UUID_SIZE, rs_IniciadoUUID },
        GATT_PERMIT_READ | GATT_PERMIT_WRITE | GATT_PERMIT_WRITE,
          0, rs_IniciadoVal },
        //CCCD
        { { ATT_BT_UUID_SIZE, clientCharCfgUUID },
        GATT_PERMIT_READ | GATT_PERMIT_WRITE,
          0, (uint8_t *) &rs_IniciadoConfig },

        //Declaracion Ciclo de lectura
        { { ATT_BT_UUID_SIZE, characterUUID },
        GATT_PERMIT_READ,
          0, &rs_Ciclo_de_lecturaProps },
        //valor
        { { ATT_UUID_SIZE, rs_Ciclo_de_lecturaUUID },
        GATT_PERMIT_READ | GATT_PERMIT_WRITE | GATT_PERMIT_WRITE,
          0, rs_Ciclo_de_lecturaVal },
        //CCCD
        { { ATT_BT_UUID_SIZE, clientCharCfgUUID },
        GATT_PERMIT_READ | GATT_PERMIT_WRITE,
          0, (uint8_t *) &rs_Ciclo_de_lecturaConfig },

        //Declaracion Time
        { { ATT_BT_UUID_SIZE, characterUUID },
        GATT_PERMIT_READ,
          0, &rs_TimeProps },
        //valor
        { { ATT_UUID_SIZE, rs_TimeUUID },
        GATT_PERMIT_READ | GATT_PERMIT_WRITE | GATT_PERMIT_WRITE,
          0, rs_TimeVal },

        //  Declaracion Estado
        { { ATT_BT_UUID_SIZE, characterUUID },
        GATT_PERMIT_READ,
          0, &rs_EstadoProps },
        //valor
        { { ATT_UUID_SIZE, rs_EstadoUUID },
        GATT_PERMIT_READ,
          0, rs_EstadoVal },
        //CCCD
        { { ATT_BT_UUID_SIZE, clientCharCfgUUID },
        GATT_PERMIT_READ | GATT_PERMIT_WRITE,
          0, (uint8_t *) &rs_EstadoConfig }, };

/*********************************************************************
 * LOCAL FUNCTIONS
 */
static bStatus_t Reader_Service_ReadAttrCB(uint16_t connHandle,
                                           gattAttribute_t *pAttr,
                                           uint8_t *pValue, uint16_t *pLen,
                                           uint16_t offset, uint16_t maxLen,
                                           uint8_t method);
static bStatus_t Reader_Service_WriteAttrCB(uint16_t connHandle,
                                            gattAttribute_t *pAttr,
                                            uint8_t *pValue, uint16_t len,
                                            uint16_t offset, uint8_t method);

static read_types_t Reader_Parse_Ciclo_De_Lectura(uint8_t * pVal);

/*********************************************************************
 * PROFILE CALLBACKS
 */
// Simple Profile Service Callbacks
CONST gattServiceCBs_t Reader_ServiceCBs = { Reader_Service_ReadAttrCB, // Read callback function pointer
        Reader_Service_WriteAttrCB, // Write callback function pointer
        NULL                       // Authorization callback function pointer
        };

/*********************************************************************
 * PUBLIC FUNCTIONS
 */

/*
 * ReaderService_AddService- Initializes the ReaderService service by registering
 *          GATT attributes with the GATT server.
 *
 *    rspTaskId - The ICall Task Id that should receive responses for Indications.
 */
extern bStatus_t ReaderService_AddService(uint8_t rspTaskId)
{
    uint8_t status;

    // asignacion de espacios a las CCCD y sus inicializaciones

    //*** Payload CCCD ***//

    rs_PayloadConfig = (gattCharCfg_t *) ICall_malloc(
            sizeof(gattCharCfg_t) * linkDBNumConns);
    if (rs_PayloadConfig == NULL)
    {
        return ( bleMemAllocError);
    }

    GATTServApp_InitCharCfg( INVALID_CONNHANDLE, rs_PayloadConfig);

    //*** Iniciado CCCD ***//

    rs_IniciadoConfig = (gattCharCfg_t *) ICall_malloc(
            sizeof(gattCharCfg_t) * linkDBNumConns);
    if (rs_IniciadoConfig == NULL)
    {
        return ( bleMemAllocError);
    }

    GATTServApp_InitCharCfg( INVALID_CONNHANDLE, rs_IniciadoConfig);

    //*** ciclo de lectura CCCD ***//

    // Allocate Client Characteristic Configuration table
    rs_Ciclo_de_lecturaConfig = (gattCharCfg_t *) ICall_malloc(
            sizeof(gattCharCfg_t) * linkDBNumConns);
    if (rs_Ciclo_de_lecturaConfig == NULL)
    {
        return ( bleMemAllocError);
    }

    GATTServApp_InitCharCfg( INVALID_CONNHANDLE, rs_Ciclo_de_lecturaConfig);

    //*** estado de conexion del modulo y el MCU CCCD ***//

    rs_EstadoConfig = (gattCharCfg_t *) ICall_malloc(
            sizeof(gattCharCfg_t) * linkDBNumConns);
    if (rs_EstadoConfig == NULL)
    {
        return ( bleMemAllocError);
    }

    GATTServApp_InitCharCfg( INVALID_CONNHANDLE, rs_Ciclo_de_lecturaConfig);

    // Register GATT attribute list and CBs with GATT Server App
    status = GATTServApp_RegisterService(Reader_ServiceAttrTbl,
                                         GATT_NUM_ATTRS(Reader_ServiceAttrTbl),
                                         GATT_MAX_ENCRYPT_KEY_SIZE,
                                         &Reader_ServiceCBs);
    Log_info1("Registered service, %d attributes", (IArg)GATT_NUM_ATTRS( Reader_ServiceAttrTbl ));
    rs_icall_rsp_task_id = rspTaskId;

    return (status);

}

/*
 * ReaderService_RegisterAppCBs - Registers the application callback function.
 *                    Only call this function once.
 *
 *    appCallbacks - pointer to application callbacks.
 */
bStatus_t ReaderService_RegisterAppCBs(ReaderServiceCBs_t *appCallbacks)
{
    if (appCallbacks)
    {
        pAppCBs = appCallbacks;
        Log_info1("Registered callbacks to application. Struct %p", (IArg)appCallbacks);
        return ( SUCCESS);
    }
    else
    {
        Log_warning0("Null pointer given for app callbacks.");
        return ( FAILURE);
    }
}

/*
 * ReaderService_SetParameter - Set a ReaderService parameter.
 *
 *    param - Profile parameter ID
 *    len   - length of data to write
 *    value - pointer to data to write.  This is dependent on
 *            the parameter ID and may be cast to the appropriate
 *            data type (example: data type of uint16_t will be cast to
 *            uint16_t pointer).
 */
bStatus_t ReaderService_SetParameter(uint8_t param, uint16_t len, void *value)
{
    bStatus_t ret = SUCCESS;
    uint8_t *pAttrVal;
    uint16_t *pValLen;
    uint16_t valMinLen;
    uint16_t valMaxLen;
    uint8_t sendNotiInd = FALSE;
    gattCharCfg_t *attrConfig;
    uint8_t needAuth;

    switch (param)
    {
    case RS_PAYLOAD_ID:
        pAttrVal = rs_PayloadVal;
        pValLen = &rs_PayloadValLen;
        valMinLen = RS_PAYLOAD_LEN_MIN;
        valMaxLen = RS_PAYLOAD_LEN;
        sendNotiInd = TRUE;
        attrConfig = rs_PayloadConfig;
        needAuth = FALSE; // Change if authenticated link is required for sending.
        Log_info2("SetParameter : %s len: %d", (IArg)"Payload", (IArg)len);
        break;

    case RS_INICIADO_ID:
        pAttrVal = rs_IniciadoVal;
        pValLen = &rs_IniciadoValLen;
        valMinLen = RS_INICIADO_LEN_MIN;
        valMaxLen = RS_INICIADO_LEN;
        sendNotiInd = TRUE;
        attrConfig = rs_IniciadoConfig;
        needAuth = FALSE; // Change if authenticated link is required for sending.
        Log_info2("SetParameter : %s len: %d", (IArg)"Iniciado", (IArg)len);
        break;

    case RS_CICLO_DE_LECTURA_ID:
        pAttrVal = rs_Ciclo_de_lecturaVal;
        pValLen = &rs_Ciclo_de_lecturaValLen;
        valMinLen = RS_CICLO_DE_LECTURA_LEN_MIN;
        valMaxLen = RS_CICLO_DE_LECTURA_LEN;
        sendNotiInd = TRUE;
        attrConfig = rs_Ciclo_de_lecturaConfig;
        needAuth = FALSE; // Change if authenticated link is required for sending.
        Log_info2("SetParameter : %s len: %d", (IArg)"Ciclo_de_lectura", (IArg)len);
        break;

    case RS_TIME_ID:
        pAttrVal = rs_TimeVal;
        pValLen = &rs_TimeValLen;
        valMinLen = RS_TIME_LEN_MIN;
        valMaxLen = RS_TIME_LEN;
        Log_info2("SetParameter : %s len: %d", (IArg)"Time", (IArg)len);
        break;

    case RS_ESTADO_ID:
        pAttrVal = rs_EstadoVal;
        pValLen = &rs_EstadoValLen;
        valMinLen = RS_ESTADO_LEN_MIN;
        valMaxLen = RS_ESTADO_LEN;
        sendNotiInd = TRUE;
        attrConfig = rs_EstadoConfig;
        needAuth = FALSE; // Change if authenticated link is required for sending.
        Log_info2("SetParameter : %s len: %d", (IArg)"Iniciado", (IArg)len);
        break;

    default:
        Log_error1("SetParameter: Parameter #%d not valid.", (IArg)param);
        return INVALIDPARAMETER;
    }

    // Check bounds, update value and send notification or indication if possible.
    if (len <= valMaxLen && len >= valMinLen)
    {
        memcpy(pAttrVal, value, len);
        *pValLen = len; // Update length for read and get.

        if (sendNotiInd)
        {
            Log_info2("Transmitting noti/ind- connHandle %d, %s", (IArg)attrConfig[0].connHandle,
                    (IArg)( (attrConfig[0].value==0)?"Noti/ind disabled":
                            (attrConfig[0].value==1)?"Notification enabled":
                            "Indication enabled" ) );
            // Try to send notification.
            GATTServApp_ProcessCharCfg(attrConfig, pAttrVal, needAuth,
                                       Reader_ServiceAttrTbl,
                                       GATT_NUM_ATTRS(Reader_ServiceAttrTbl),
                                       rs_icall_rsp_task_id,
                                       Reader_Service_ReadAttrCB);
        }
    }
    else
    {
        Log_error3("Length outside bounds: Len: %d MinLen: %d MaxLen: %d.", (IArg)len, (IArg)valMinLen, (IArg)valMaxLen);
        ret = bleInvalidRange;
    }

    return ret;
}

/*
 * ReaderService_GetParameter - Get a ReaderService parameter.
 *
 *    param - Profile parameter ID
 *    len   - pointer to a variable that contains the maximum length that can be written to *value.
 After the call, this value will contain the actual returned length.
 *    value - pointer to data to write.  This is dependent on
 *            the parameter ID and may be cast to the appropriate
 *            data type (example: data type of uint16_t will be cast to
 *            uint16_t pointer).
 */
bStatus_t ReaderService_GetParameter(uint8_t param, uint16_t *len, void *value)
{
    bStatus_t ret = SUCCESS;
    switch (param)
    {
    case RS_INICIADO_ID:
        *len = MIN(*len, rs_IniciadoValLen);
        memcpy(value, rs_IniciadoVal, *len);
        Log_info2("GetParameter : %s returning %d bytes", (IArg)"Iniciado", (IArg)*len);
        break;

    case RS_CICLO_DE_LECTURA_ID:
        *len = MIN(*len, rs_Ciclo_de_lecturaValLen);
        memcpy(value, rs_Ciclo_de_lecturaVal, *len);
        Log_info2("GetParameter : %s returning %d bytes", (IArg)"Ciclo_de_lectura", (IArg)*len);
        break;

    case RS_TIME_ID:
        *len = MIN(*len, rs_TimeValLen);
        memcpy(value, rs_TimeVal, *len);
        Log_info2("GetParameter : %s returning %d bytes", (IArg)"Time", (IArg)*len);
        break;

    case RS_ESTADO_ID:
        *len = MIN(*len, rs_EstadoValLen);
        memcpy(value, rs_EstadoVal, *len);
        Log_info2("GetParameter : %s returning %d bytes", (IArg)"Iniciado", (IArg)*len);
        break;

    default:
        Log_error1("GetParameter: Parameter #%d not valid.", (IArg)param);
        ret = INVALIDPARAMETER;
        break;
    }
    return ret;
}

/*********************************************************************
 * @internal
 * @fn          Reader_Service_findCharParamId
 *
 * @brief       Find the logical param id of an attribute in the service's attr table.
 *
 *              Works only for Characteristic Value attributes and
 *              Client Characteristic Configuration Descriptor attributes.
 *
 * @param       pAttr - pointer to attribute
 *
 * @return      uint8_t paramID (ref Reader_Service.h) or 0xFF if not found.
 */
static uint8_t Reader_Service_findCharParamId(gattAttribute_t *pAttr)
{
    // Is this a Client Characteristic Configuration Descriptor?
    if (ATT_BT_UUID_SIZE == pAttr->type.len
            && GATT_CLIENT_CHAR_CFG_UUID == *(uint16_t *) pAttr->type.uuid)
        return Reader_Service_findCharParamId(pAttr - 1); // Assume the value attribute precedes CCCD and recurse

    // Is this attribute in "payload"?
    else if ( ATT_UUID_SIZE == pAttr->type.len
            && !memcmp(pAttr->type.uuid, rs_PayloadUUID, pAttr->type.len))
        return RS_PAYLOAD_ID;

    else if ( ATT_UUID_SIZE == pAttr->type.len
            && !memcmp(pAttr->type.uuid, rs_IniciadoUUID, pAttr->type.len))
        return RS_INICIADO_ID;

    else if ( ATT_UUID_SIZE == pAttr->type.len
            && !memcmp(pAttr->type.uuid, rs_Ciclo_de_lecturaUUID,
                       pAttr->type.len))
        return RS_CICLO_DE_LECTURA_ID;

    else if ( ATT_UUID_SIZE == pAttr->type.len
            && !memcmp(pAttr->type.uuid, rs_TimeUUID, pAttr->type.len))
        return RS_TIME_ID;

    else if ( ATT_UUID_SIZE == pAttr->type.len
            && !memcmp(pAttr->type.uuid, rs_EstadoUUID, pAttr->type.len))
        return RS_ESTADO_ID;

    else
        return 0xFF; // Not found. Return invalid.
}

/*********************************************************************
 * @fn          Reader_Service_ReadAttrCB
 *
 * @brief       Read an attribute.
 *
 * @param       connHandle - connection message was received on
 * @param       pAttr - pointer to attribute
 * @param       pValue - pointer to data to be read
 * @param       pLen - length of data to be read
 * @param       offset - offset of the first octet to be read
 * @param       maxLen - maximum length of data to be read
 * @param       method - type of read message
 *
 * @return      SUCCESS, blePending or Failure
 */
static bStatus_t Reader_Service_ReadAttrCB(uint16_t connHandle,
                                           gattAttribute_t *pAttr,
                                           uint8_t *pValue, uint16_t *pLen,
                                           uint16_t offset, uint16_t maxLen,
                                           uint8_t method)
{
    bStatus_t status = SUCCESS;
    uint16_t valueLen;
    uint8_t paramID = 0xFF;

    // Find settings for the characteristic to be read.
    paramID = Reader_Service_findCharParamId(pAttr);
    switch (paramID)
    {
    case RS_PAYLOAD_ID:
        valueLen = rs_PayloadValLen;

        Log_info4("ReadAttrCB : %s connHandle: %d offset: %d method: 0x%02x",
                (IArg)"Payload",
                (IArg)connHandle,
                (IArg)offset,
                (IArg)method);
        /* Other considerations for payload can be inserted here */
        break;

    case RS_INICIADO_ID:
        valueLen = rs_IniciadoValLen;

        Log_info4("ReadAttrCB : %s connHandle: %d offset: %d method: 0x%02x",
                (IArg)"Iniciado",
                (IArg)connHandle,
                (IArg)offset,
                (IArg)method);
        /* Other considerations for iniciado can be inserted here */
        break;

    case RS_CICLO_DE_LECTURA_ID:
        valueLen = rs_Ciclo_de_lecturaValLen;

        Log_info4("ReadAttrCB : %s connHandle: %d offset: %d method: 0x%02x",
                (IArg)"Ciclo_de_lectura",
                (IArg)connHandle,
                (IArg)offset,
                (IArg)method);
        /* Other considerations for ciclo de lectura can be inserted here */
        break;

    case RS_TIME_ID:
        valueLen = rs_TimeValLen;

        Log_info4("ReadAttrCB : %s connHandle: %d offset: %d method: 0x%02x",
                (IArg)"Time",
                (IArg)connHandle,
                (IArg)offset,
                (IArg)method);
        /* Other considerations for time can be inserted here */
        break;

    case RS_ESTADO_ID:
        valueLen = rs_IniciadoValLen;

        Log_info4("ReadAttrCB : %s connHandle: %d offset: %d method: 0x%02x",
                (IArg)"estado",
                (IArg)connHandle,
                (IArg)offset,
                (IArg)method);
        /* Other considerations for estado can be inserted here */
        break;

    default:
        Log_error0("Attribute was not found.");
        return ATT_ERR_ATTR_NOT_FOUND;
    }
    // Check bounds and return the value
    if (offset > valueLen)  // Prevent malicious ATT ReadBlob offsets.
    {
        Log_error0("An invalid offset was requested.");
        status = ATT_ERR_INVALID_OFFSET;
    }
    else
    {
        *pLen = MIN(maxLen, valueLen - offset);  // Transmit as much as possible
        memcpy(pValue, pAttr->pValue + offset, *pLen);
    }

    return status;
}

/*********************************************************************
 * @fn      Reader_Service_WriteAttrCB
 *
 * @brief   Validate attribute data prior to a write operation
 *
 * @param   connHandle - connection message was received on
 * @param   pAttr - pointer to attribute
 * @param   pValue - pointer to data to be written
 * @param   len - length of data
 * @param   offset - offset of the first octet to be written
 * @param   method - type of write message
 *
 * @return  SUCCESS, blePending or Failure
 */
static bStatus_t Reader_Service_WriteAttrCB(uint16_t connHandle,
                                            gattAttribute_t *pAttr,
                                            uint8_t *pValue, uint16_t len,
                                            uint16_t offset, uint8_t method)
{
    bStatus_t status = SUCCESS;
    uint8_t paramID = 0xFF;
    uint8_t changeParamID = 0xFF;
    uint16_t writeLenMin;
    uint16_t writeLenMax;
    uint16_t *pValueLenVar;

    // See if request is regarding a Client Characterisic Configuration
    if (ATT_BT_UUID_SIZE == pAttr->type.len
            && GATT_CLIENT_CHAR_CFG_UUID == *(uint16_t *) pAttr->type.uuid)
    {
        // Allow notification and indication, but do not check if really allowed per CCCD.
        status = GATTServApp_ProcessCCCWriteReq(connHandle, pAttr, pValue, len,
                                                offset, GATT_CLIENT_CFG_NOTIFY |
                                                GATT_CLIENT_CFG_INDICATE);
        if (SUCCESS == status && pAppCBs && pAppCBs->pfnCfgChangeCb)
            pAppCBs->pfnCfgChangeCb(connHandle, READER_SERVICE_SERV_UUID,
                                    Reader_Service_findCharParamId(pAttr),
                                    pValue, len);

        return status;
    }

    // Find settings for the characteristic to be written.
    paramID = Reader_Service_findCharParamId(pAttr);
    switch (paramID)
    {
    case RS_INICIADO_ID:
        writeLenMin = RS_INICIADO_LEN_MIN;
        writeLenMax = RS_INICIADO_LEN;
        pValueLenVar = &rs_IniciadoValLen;

        Log_info5("WriteAttrCB : %s connHandle(%d) len(%d) offset(%d) method(0x%02x)",
                (IArg)"Iniciado",
                (IArg)connHandle,
                (IArg)len,
                (IArg)offset,
                (IArg)method);
        //no comenzar lecturas a menos que el ciclo de lectura este seteado
        if (Reader_Parse_Ciclo_De_Lectura(rs_Ciclo_de_lecturaVal) == NONE)
        {
            Log_info0("No se ha establecido el cliclo de lectura");
            return ATT_ERR_WRITE_NOT_PERMITTED;
        }
        break;

    case RS_CICLO_DE_LECTURA_ID:
        writeLenMin = RS_CICLO_DE_LECTURA_LEN_MIN;
        writeLenMax = RS_CICLO_DE_LECTURA_LEN;
        pValueLenVar = &rs_Ciclo_de_lecturaValLen;

        Log_info5("WriteAttrCB : %s connHandle(%d) len(%d) offset(%d) method(0x%02x)",
                (IArg)"Ciclo_de_lectura",
                (IArg)connHandle,
                (IArg)len,
                (IArg)offset,
                (IArg)method);
        //no establecer ciclo de lectura a menos que el tiempo se encuentre asignado si no este no es opcional
        if (Reader_Parse_Ciclo_De_Lectura(pValue) != ONE_SHOT
                && Reader_Parse_Ciclo_De_Lectura(pValue) != NONE)
        {
            if (*rs_TimeVal == 0)
            {
                Log_info0("No se ha establecido el tiempo por ejecucion");
                return ATT_ERR_WRITE_NOT_PERMITTED;
            }
        }
        break;

    case RS_TIME_ID:
        writeLenMin = RS_TIME_LEN_MIN;
        writeLenMax = RS_TIME_LEN;
        pValueLenVar = &rs_TimeValLen;

        Log_info5("WriteAttrCB : %s connHandle(%d) len(%d) offset(%d) method(0x%02x)",
                (IArg)"Time",
                (IArg)connHandle,
                (IArg)len,
                (IArg)offset,
                (IArg)method);
        break;

    default:
        Log_error0("Attribute was not found.");
        return ATT_ERR_ATTR_NOT_FOUND;
    }
    // Check whether the length is within bounds.
    if (offset >= writeLenMax)
    {
        Log_error0("An invalid offset was requested.");
        status = ATT_ERR_INVALID_OFFSET;
    }
    else if (offset + len > writeLenMax)
    {
        Log_error0("Invalid value length was received.");
        status = ATT_ERR_INVALID_VALUE_SIZE;
    }
    else if (offset + len < writeLenMin
            && (method == ATT_EXECUTE_WRITE_REQ || method == ATT_WRITE_REQ))
    {
        // Refuse writes that are lower than minimum.
        // Note: Cannot determine if a Reliable Write (to several chars) is finished, so those will
        //       only be refused if this attribute is the last in the queue (method is execute).
        //       Otherwise, reliable writes are accepted and parsed piecemeal.
        Log_error0("Invalid value length was received.");
        status = ATT_ERR_INVALID_VALUE_SIZE;
    }
    else
    {
        // Copy pValue into the variable we point to from the attribute table.
        memcpy(pAttr->pValue + offset, pValue, len);

        // Only notify application and update length if enough data is written.
        //
        // Note: If reliable writes are used (meaning several attributes are written to using ATT PrepareWrite),
        //       the application will get a callback for every write with an offset + len larger than _LEN_MIN.
        // Note: For Long Writes (ATT Prepare + Execute towards only one attribute) only one callback will be issued,
        //       because the write fragments are concatenated before being sent here.
        if (offset + len >= writeLenMin)
        {
            changeParamID = paramID;
            *pValueLenVar = offset + len; // Update data length.
        }
    }

    // Let the application know something changed (if it did) by using the
    // callback it registered earlier (if it did).
    if (changeParamID != 0xFF)
        if (pAppCBs && pAppCBs->pfnChangeCb)
            pAppCBs->pfnChangeCb(connHandle, READER_SERVICE_SERV_UUID, paramID,
                                 pValue, len + offset); // Call app function from stack task context.

    return status;
}

static read_types_t Reader_Parse_Ciclo_De_Lectura(uint8_t * pVal)
{

    read_types_t tipo = (read_types_t) *pVal;

    return tipo;
}

//static void establecerTipoDeLectura(read_types_t rt){
//    if(rt == CONTINOUS || rt == NONE){
//
//        tipo_de_lectura = rt;
//
//    }
//
//
//
//
//
//
//
//
//}
